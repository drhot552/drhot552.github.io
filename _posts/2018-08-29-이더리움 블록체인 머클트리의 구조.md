---
title:  "[BlockChain]이더리움 블록체인_머클트리의 구조"

categories:
  - blockchain
last_modified_at: 2018-08-29T08:06:00-05:00
tags:
  - Blockchain
---

이더리움 블록체인을 이해하는 것은 굉장히 어렵습니다. 특히 이더리움 블록체인이 등장하고 스마트컨트랙트라는 개념이 처음 생겼기 때문에, 스마트컨트랙트가 어떻게 구동 되는지 쉽게 알기 어렵습니다.

기본적으로 **블록체인 해쉬 알고리즘 머클 패트리샤 트리와 가스 값, Nonce(bold)** 등 블록체인을 이해하기 위해서는 앞선 용어에 대한 이해가 필요하죠.

이번 포스팅에서는 머클트리와 그 알고리즘에 대해서 알아보도록 하겠습니다.

# 머클트리

## 1. 머클트리는 왜 사용하는 것일까?

머클트리는 블록체인 분산원장을 관리하는데 매우 중요한 알고리즘 입니다.

블록체인의 크기가 늘어날 수록 블록체인의 동기화를 하는데 많은 자원이 들 수 밖에 없습니다.  
모바일이나 태블릿 PC로 블록체인을 동기화하는데는 불가능에 가까울 수 도 있을 거에요.  
때문에 이를 보완하고자 머클트리의 루트 정보를 블록에 저장하여 블록의 정보 조회에 대한 효율성을 높이기 위해 머클트리는 사용하는 겁니다.(경량동기화)

뿐 만아니라 블록체인의 작업증명방식을 하는데도 머클트리의 Root Hash정보만으로도 증명이 가능한 것이죠.

블록체인은 아래와 같이 3개의 동기화로 나누어집니다.

- 전체동기화 : 전체블록을 동기화합니다. 마이이더월렛을 설치하다보면 하드디스크의 많은 용량을 차지하는 경우가 생기는데 이는 이더리움의 블록을 전체로 다운로드 했기 때문입니다.
- 빠른동기화 : 최근의 상태, 트랜잭션, 리시트 등의 포함하는 블록 헤더만을 동기화 합니다. 때문에 유효성 검사는 하기 어렵죠.
- 경량동기화 : 블록체인의 상태만 동기화 합니다.

## 2. 머클트리가 무엇일까?

머클트리는 자료구조 트리의 개념을 알아야 이해하기가 훨씬 쉽습니다.  
트리의 개념자체가 크게 어렵지 않기 때문에 트리의 자세한 개념을 모르더라도 머클트리가 무엇인지에 대해 쉽게 아래 그림만 보고 이해할 수 있죠.

![Image Alt 텍스트](/assets/img/mercle_1.jpg)

<머클트리 구조 / 출처 : 머클트리구조>

### 머클트리

1. 거래 1 + 거래 2 => 거래 1+2

2. 거래 3+ 거래 4 => 거래 3+4

3. 거래 (1+2) + 거래 (2+3) => 거래(1+2+3+4)

거래 1과 거래 2를 해쉬화 해서 거래(1+2)를 만들고, 거래 3과 거래 4를 해쉬화하여거래(3+4)를 만듭니다. 이런 일련의 해쉬 과정들을 통해서 최종적으로 거래(1+2+3+4+5+6+7+8)의 해쉬값이 만들어지죠.

결국 블록체인의 머클루트의 루트 해쉬값만 있으면 거래 1에 대한 거래 내역을 찾을 수 있는 겁니다.

이더리움이나 비트코인 블록체인에는 이런 머클트리 알고리즘이 들어가 있으며 실제 거래가 발생하면 머클트리의 루트값이 변경되는 이유가 바로 이 때문입니다.

## 3. 상태전이 머클패트리시아 트리

블록체인에 존재하는 계좌번호는 상태가 계속해서 변경될 수 있습니다.

(블록체인 해쉬는 State Root, Txhash, ReceiptHash 가 존재합니다. 여기서 State Root가 머클패트리시아 트리를 사용합니다.)

계좌번호에 대한 생성, 상태, 키, 값 등 여러 정보가 변경 되면 머클트리는 매번 앞선 트리의 재계산을 해야 하므로 시간이 상대적으로 오래 걸릴 수 밖에 없습니다. 즉 상태가 자주 변하게 될 경우 머클트리에서도 문제가 발생할 수 있게 되죠.

때문에 이더리움 블록체인 개발진들이 두가지 기능을 추가하였는데, 하나는 패트리시아 트리기능과 하나는 트리의 깊이를 정하는 것이었습니다.

### 머클패트리시아 트리

![Image Alt 텍스트](/assets/img/mercle_2.png)

<머클패트리시아 구조 / 출처 : 쉽게이해하는 머클트리 >

1 ~ 7번까지 공통된 R이 루트 노드입니다. 즉 공통 노드를 기준으로 노드들이 이어지는 방식입니다.  
이를 이더리움 블록체인에 적용하게 되면 크게 Extension Node, Branch Node, LeafNode로 나눠어집니다.

또한 선행구분자에 따라서 경로값의 길이가 결정되며 노드 타입또한 결정됩니다.

선행구분자

0 , 1 -> 확장노드

2 , 3 -> 리프노드

![Image Alt 텍스트](/assets/img/mercle_3.png)

저 그림대로 같은 정보에 대한 노드는 Branch 노드에 저장하고 이를 LeafNode로 뻗어나가면서 트리에 대한 정보를 최소화 하는 것입니다.

# 상태전이

상태전이는 말그대로 상태를 Update한다 입니다. 즉 계좌 잔액이나 상태를 업데이트 하는 것을 말합니다. 이건 당연하지 않나? 라고 생각 할 수 있지만, 비트코인의 경우에는 상태를 Update하지 않고 거래내역을 저장하는 구조입니다.

예를들어서 **A : 100 BTC, B: 0BTC(bold)** 가 있다고 합시다. 그런데 A에서 B에게 **50 BTC** 를 준다고하면 상식적으로 A와 B의 잔액은 50BTC입니다. 하지만 비트코인 거래는 **A의 100BTC** 의 내용은 그대로 있고 **A-50BTC와 B-50BTC** 의 거래내역을 저장하는 방식입니다.  
즉 전 상태값을 그대로 두는거죠.

이 방법은 자원을 상태전이에 비해 상대적으로 많이 차지할 수 있지만, 거래내역을 저장한다는 점에서는 금융거래에 있어 중요한 방식입니다.

이처럼 비트코인과 다르게 이더리움은 상태전이(거래내역 Update)의 특징을 가지고 있습니다. 그렇다고 이더리움이 모든 거래내역을 바로 Update하는 것은 아닙니다. 기존 거래에 대한 내역을 저장하고 있다가 블록에 대한 거래에 이상이 없다 판단되면 상태전이를 일으키는 것이죠.
