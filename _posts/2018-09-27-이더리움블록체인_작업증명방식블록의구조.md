---
title:  "[BlockChain]이더리움 블록체인_작업증명방식과 블록의 구조"

categories:
  - blockchain
last_modified_at: 2018-09-27T12:06:00-05:00
tags:
  - Blockchain
---
이더리움은 비트코인과 마찬가지로 작업증명방식(POW)로 블록체인의 합의를 이끌어 냅니다. 복잡한 계산 문제의 해답을 가장 빨리 찾은 마이너의 블록을 등록하고 이에 따라 보상을 하는 방식입니다.

# 작업증명방식
작업증명방식은 Miner(채굴자)가 존재하며, 이에 따른 Mining(채굴)을 하는 구조 입니다. Miner는 일련의 트랜잭션들을 모아 하나의 신규블록을 구성하게 됩니다.

![Image Alt 텍스트](/assets/img/pow.png)

<작업증명방식 / 출처 : [작업증명방식](https://ihpark92.tistory.com/51)>

기본적으로 블록체인은 자료구조 링크드리스트와 매우 닮아 있습니다. 각각의 블록의 구조는 이전블록의 해쉬값을 저장하고 있고, 각각의 트랜잭션 거래들의 해쉬값을 통해 블록을 만들고 있습니다. 즉 블록안의 구조는 Mercle Tree root, nonce, PrevHashblock으로 이루어져 있습니다.

## MercleTree Root

머클트리루트는 하나의 거래들을 모아놓은 헤더정보라고 생각하시면 됩니다. 하나의 트리를 생각했을 때 가장 위 부모노드를 머클트리 루트라고합니다.

## Nonce

블록체인의 작업증명방식을 이루기 위한 값입니다. 블록체인의 마이너는 Nonce값을 대입하면서 특정 블록보다 작은 해쉬값을 찾는 과정을 하게 됩니다. 이런 과정은 무작위로 대입되며 연산과정을 거치게 됩니다. 만약 해쉬값을 찾게 되면 블록을 생성하게 되고 마이너는 보상을 얻게 되죠.

![Image Alt 텍스트](/assets/img/pow_1.png)
<블록체인 / 출처 : [블록체인한번에 이해하기](https://homoefficio.github.io/2017/11/19/%EB%B8%94%EB%A1%9D%EC%B2%B4%EC%9D%B8-%ED%95%9C-%EB%B2%88%EC%97%90-%EC%9D%B4%ED%95%B4%ED%95%98%EA%B8%B0/)>

위 그림을 보면 Nonce의 값을 0부터 대입합니다. 만약 nonce값을 통해서 000000a82가 나온다면 블록을 생성하게 됩니다. 여기서 나오는 해쉬값은 nonce와 difficulty(난이도)에 따라 달라지게 되고, 이는 많은 연산작업이 소요되는 일입니다. 즉 블록의 생성 난이도가 높아지고 찾아야되는 해쉬값이 점점 낮은 값으로 이루어진다면 엄청난 컴퓨팅 파워가 필요하게 되죠.

> 목표값 = 2²⁵⁶ / 난이도(Difficulty)

암호 해시값 <= 목표값

=> 간단하게 말해서 Nonce 값을 차례대로 증가시켜 결과값을 찾는 과정을 하게 됩니다.

이것이 바로 작업증명(POW)방식입니다. 비트코인 블록체인에서는 이런 해시값을 찾는 과정에서 많은 자원이 들기 때문에 최근 마이너들에게 비트코인이 중앙집중화 되는 모습을 보이기도 했습니다. 탈중앙화인데 역기능이 발생하게 되어버린것이죠..

# Block 구성요소

블록의 기본적인 구성요소는 아래와 같습니다. 블록체인 헤더에는 Nonce, 이전Hash, 머클루트 뿐 만 아니라 다양한 정보들을 담고있습니다.

ParentHash, coinbase(마이닝작업 후 이더를 지급받을 주소), Block Num, Uncle Hash, Extra Data(현재 블록과 관련된 추가정보), Gas Limit, Gas Used, Difficulty, Nonce, Mix Hash, Bloom(로그정보검색) 등을 가지고 있죠.

# 이대시(Ethash)

이더리움의 합의 구조를 이대시라고 합니다. 기존 비트코인 같은 경우 메모리를 쓰지 않고 GPU와 CPU 병렬계산에 마이닝 초점을 두었습니다. 때문에 ASIC칩을 이용한 고성능 GPU카드가 필요했죠. 하지만 이더리움의 이대시는 ASIC 칩을 무력화한 마이닝으로 메모리를 쓰는 방식입니다. 중앙집중되는 것을 막고 경량 클라이언트에서도 블록을 검증할 수 있게 했습니다. 이대시는 DAG(Direct Acyclic Graph)알고리즘을 사용하고 있습니다. Geth를 이용해서 로컬로 마이닝을 구동을 시키게 되면 2GB 정도 다운로드 받게 되는데 바로 이것이 DAG파일입니다.

![Image Alt 텍스트](/assets/img/dag.png)

<DAG 이미지 / 출처 : [위키피디아](https://en.wikipedia.org/wiki/Directed_acyclic_graph)>

> => DAG가 무엇인가??

방향성 비순환 그래프 입니다. 블록체인의 체인만 저장함으로써 한 트랜잭션이 다음 트랜잭션을 증명하는 방식입니다. 즉 이더리움은 이런 체인 구조만 저장하게 함으로써 블록체인의 뼈대를 생성하게 되는거죠.

# 엉클 블록 / 고스트 프로토콜

## 엉클블록이란 무엇일까??

이처럼 블록생성을 성공적으로 생성하게 되면 블록체인에 정상적으로 블록이 등록되게 됩니다. 하지만 다른마이너가 동시에 블록을 생성해서 등록하게 되면 이더리움 블록체인은 두 개의 블록을 한번에 올릴 수 없게 됩니다. 즉 하나의 블록만이 블록체인에 올라가고 나머지 하나는 버려지게 되는데, 이 때 버려지는 블록을 엉클블록이라고 합니다. (한마디로 고아블록이라고도 하죠)

만약 A블록과 B블록이 동시에 생성됬다면 Nonce값과 난이도 등을 비교해서 더어려운 난이도와 큰 Nonce값을 가진 블록이 올라가게 되는거죠. 그럼 버려진 블록은 고아처럼 남게 됩니다.

이처럼 엉클블록이 많아지면 블록체인에 문제가 일어나게 됩니다. 엉클블록들은 실제 블록을 검증하는데 추가적으로 검증하기 때문에 쓸 때 없는 자원을 낭비하게 됩니다. 뿐 만 아니라 블록체인의 정합성과 안정성도 현저히 떨어지게 되죠.


## 엉클블록 구조

![Image Alt 텍스트](/assets/img/uncleblock.png)

## 엉클블록의 문제를 해결하는 방법

때문에 이더리움은 엉클블록 문제를 고스트 프로토콜이라는 알고리즘을 사용해서 해결합니다.
즉 블록생성시 정상 블록에 최대 2개의 엉클블록을 추가하고 보상하여 이 문제를 해결합니다.
고스트 프로토콜은 Greedy Heaviest Object subTree의 약자이고 이는 가장 큰 무게를 가진 subTree를 선택하는 알고리즘 입니다.
보통 비트코인의 경우에는 엉클블록을 버리게 되지만 이더리움은 수정된 고스트 프로토콜을 사용하게 되죠.

![Image Alt 텍스트](/assets/img/ghost.png)

<고스트프로토콜 / 출처 : [고스트프로토콜구조](https://medium.com/tomak/ethereum-ghost-protocol에-대한-이해-56590765eb18)>

# 고스트프로토콜

여기서 0–1B — 2C — (3E, 3D, 3C) — 4B 가 가장 무게가 큰 트리이므로 메인체인으로 붙게 됩니다. 이 구조가 바로 고스트프로토콜의 구조입니다.

1. 하나의 블록은 반드시 하나의 부모 블록을 지정하며, 0 또는 그 이상의 엉클 블록을 지정한다. 현재 2개까지 지원하고 있다.

2. 블록 A의 K번째 조상의 직접적인 자손이어야 한다.

3. 블록 A의 조상이어서는 안된다.

엉클블록 마이너 보상은 블록 생성 시에 받는 보상의 93.75%를 보상으로 받고, 엉클 블록이 포함된 정상블록의 마이너는 엉클블록 1개당 3.125%의 추가 보상을 받게 됩니다.

- 블록전파와 포크
생성된 블록들은 주변노드에 브로드캐스팅(전파)을 합니다. 각 노드들은 작업증명을 통해서 해시 계산이 맞는지를 확인하게 됩니다. 이 때 블록의 내용이 틀리게 되면 이 블록은 블록체인에서 잘못된 등록이라 판단되는 것이죠. 이를 유효성 검사라고 하는데 이상이 없으면 블록이 정상적으로 등록되게 됩니다.

포크는 소프트웨어를 업데이트 하는 것을 말합니다. 블록체인에서의 포크는 두가지로 나누어지는데 ‘하드포크’와 ‘소프트포크’입니다.

# 소프트포크

이전 버전과 신규 버전의 블록체인이 호환이 되는 블록체인 업데이트입니다. 즉 사용자들은 업데이트를 할 필요가 없고 마이너들만 업그레이드 하는 경우를 말합니다.

# 하드포크

모든 마이너와 사용자들이 반드시 업데이트를 해야되는 경우입니다. 이는 기존 블록체인과 호환이 되지 않기 때문에 따로 떨어져서 블록체인이 생성됩니다.

(Ex: 이더리움 클래식(기존 이더리움블록체인) — 이더리움의 하드포크한 버전이 현재이더리움이고 DAO해킹으로 인한 이더리움 기존버전이 이더리움 클래식 입니다, 비트코인의 Segwit문제에 대한 비트코인캐시 등등)

블록의 크기를 변경하거나 블록의 리시트, 정보 등이 변경되어 기존 블록과 호한이 되지 않는 경우가 하드포크입니다.
